/**
 * AWS Lambda Function: DynamoDB Events Handler
 * 
 * This Lambda function handles DynamoDB operations for Events via API Gateway.
 * It uses the Lambda execution role (auto-generated by AWS Academy) to access DynamoDB.
 * 
 * Deployment:
 * 1. Copy this file to Lambda console as index.js (or update handler name)
 * 2. Set handler to: index.handler
 * 3. Set runtime to: Node.js 18.x or later
 * 4. Configure environment variable: EVENTS_TABLE_NAME
 * 5. Attach IAM policy to execution role: dynamodb:GetItem, dynamodb:PutItem, dynamodb:UpdateItem, dynamodb:DeleteItem, dynamodb:Scan
 * 6. Set timeout to 30 seconds
 * 7. Set memory to 256 MB
 * 
 * Note: AWS SDK v2 is built into Lambda runtime, no need to install
 */

const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

/**
 * Lambda handler function
 * @param {Object} event - API Gateway event
 * @param {Object} context - Lambda context
 * @returns {Object} API Gateway response
 */
exports.handler = async (event) => {
  console.log('Received DynamoDB request:', JSON.stringify(event, null, 2));
  
  try {
    // Parse request body
    let body;
    try {
      body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
    } catch (parseError) {
      throw new Error('Invalid JSON in request body');
    }
    
    // Get HTTP method and operation
    const httpMethod = event.httpMethod || event.requestContext?.http?.method || 'GET';
    const operation = body.operation || httpMethod.toLowerCase();
    
    // Check if this is an alumni profile operation
    const isAlumniOperation = operation.includes('AlumniProfile') || operation.includes('alumniProfile');
    const tableName = isAlumniOperation 
      ? (process.env.ALUMNI_PROFILES_TABLE_NAME || 'alumni_profiles')
      : (process.env.EVENTS_TABLE_NAME || 'Events');
    
    let result;
    
    // Handle Alumni Profile operations
    if (isAlumniOperation) {
      switch (operation) {
        case 'getAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for getAlumniProfile operation');
          }
          
          // Ensure userId is a number (DynamoDB requires exact type match)
          const getUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(getUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          result = await dynamodb.get({
            TableName: tableName,
            Key: { userId: getUserId }
          }).promise();
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: result.Item || null,
            }),
          };
          
        case 'putAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for putAlumniProfile operation');
          }
          
          if (!body.profileData) {
            throw new Error('profileData is required for putAlumniProfile operation');
          }
          
          // Ensure userId is a number (DynamoDB requires exact type match)
          const putUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(putUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const now = new Date().toISOString();
          
          const existingAlumniProfile = await dynamodb.get({
            TableName: tableName,
            Key: { userId: putUserId }
          }).promise();
          
          const alumniProfileData = {
            userId: putUserId,
            skills: body.profileData.skills || [],
            aspirations: body.profileData.aspirations || null,
            parsed_resume: body.profileData.parsed_resume || null,
            projects: body.profileData.projects || [],
            experiences: body.profileData.experiences || [],
            achievements: body.profileData.achievements || [],
            resume_url: body.profileData.resume_url || null,
            updatedAt: now,
          };
          
          if (existingAlumniProfile.Item && existingAlumniProfile.Item.createdAt) {
            alumniProfileData.createdAt = existingAlumniProfile.Item.createdAt;
          } else {
            alumniProfileData.createdAt = now;
          }
          
          await dynamodb.put({
            TableName: tableName,
            Item: alumniProfileData,
          }).promise();
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: alumniProfileData,
            }),
          };
          
        case 'updateAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for updateAlumniProfile operation');
          }
          
          // Ensure userId is a number
          const updateUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(updateUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const alumniProfileToUpdate = await dynamodb.get({
            TableName: tableName,
            Key: { userId: updateUserId }
          }).promise();
          
          if (!alumniProfileToUpdate.Item) {
            return {
              statusCode: 404,
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
              body: JSON.stringify({
                success: false,
                error: 'Alumni profile not found',
              }),
            };
          }
          
          const alumniUpdateExpressions = [];
          const alumniExpressionAttributeNames = {};
          const alumniExpressionAttributeValues = {};
          
          const alumniUpdateFields = ['skills', 'aspirations', 'parsed_resume', 'projects', 'experiences', 'achievements', 'resume_url'];
          alumniUpdateFields.forEach((field, index) => {
            if (body.profileData && body.profileData[field] !== undefined) {
              const nameKey = `#attr${index}`;
              const valueKey = `:val${index}`;
              alumniUpdateExpressions.push(`${nameKey} = ${valueKey}`);
              alumniExpressionAttributeNames[nameKey] = field;
              alumniExpressionAttributeValues[valueKey] = body.profileData[field];
            }
          });
          
          const alumniUpdatedAtKey = `#attr${alumniUpdateExpressions.length}`;
          const alumniUpdatedAtValue = `:val${alumniUpdateExpressions.length}`;
          alumniUpdateExpressions.push(`${alumniUpdatedAtKey} = ${alumniUpdatedAtValue}`);
          alumniExpressionAttributeNames[alumniUpdatedAtKey] = 'updatedAt';
          alumniExpressionAttributeValues[alumniUpdatedAtValue] = new Date().toISOString();
          
          if (alumniUpdateExpressions.length === 0) {
            throw new Error('No fields to update');
          }
          
          const alumniUpdateResult = await dynamodb.update({
            TableName: tableName,
            Key: { userId: updateUserId },
            UpdateExpression: `SET ${alumniUpdateExpressions.join(', ')}`,
            ExpressionAttributeNames: alumniExpressionAttributeNames,
            ExpressionAttributeValues: alumniExpressionAttributeValues,
            ReturnValues: 'ALL_NEW',
          }).promise();
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: alumniUpdateResult.Attributes,
            }),
          };
          
        case 'deleteAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for deleteAlumniProfile operation');
          }
          
          // Ensure userId is a number
          const deleteUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(deleteUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const alumniProfileToDelete = await dynamodb.get({
            TableName: tableName,
            Key: { userId: deleteUserId }
          }).promise();
          
          if (!alumniProfileToDelete.Item) {
            return {
              statusCode: 404,
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
              body: JSON.stringify({
                success: false,
                error: 'Alumni profile not found',
              }),
            };
          }
          
          await dynamodb.delete({
            TableName: tableName,
            Key: { userId: deleteUserId }
          }).promise();
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              message: 'Alumni profile deleted successfully',
            }),
          };
          
        default:
          throw new Error(`Unsupported alumni operation: ${operation}`);
      }
    }
    
    // Handle Events operations (existing code)
    switch (operation) {
      case 'get':
      case 'GET':
        // Get event by ID
        if (!body.eventId) {
          throw new Error('eventId is required for get operation');
        }
        result = await dynamodb.get({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }).promise();
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: result.Item || null,
          }),
        };
        
      case 'getAll':
      case 'scan':
      case 'GET':
        // Get all events (if no eventId provided)
        if (httpMethod === 'GET' && !body.eventId) {
          const scanResult = await dynamodb.scan({
            TableName: tableName,
          }).promise();
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: scanResult.Items || [],
            }),
          };
        }
        break;
        
      case 'create':
      case 'POST':
        // Create new event
        // Support both old format (title/description) and new format (eventInfo)
        const hasOldFormat = body.title && body.description;
        const hasNewFormat = body.eventInfo && body.eventInfo.name && body.eventInfo.description;
        
        if (!hasOldFormat && !hasNewFormat) {
          throw new Error('Either (title and description) or (eventInfo with name and description) is required for create operation');
        }
        
        // Generate event ID
        const eventId = body.eventId || `EVT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date().toISOString();
        
        // Build eventInfo from either format
        let eventInfo;
        if (hasNewFormat) {
          eventInfo = body.eventInfo;
        } else {
          // Convert old format to new format
          eventInfo = {
            name: body.title,
            description: body.description,
            ...(body.photos && { photos: body.photos }),
            ...(body.date && { date: body.date }),
          };
        }
        
        const newEvent = {
          eventId,
          eventInfo: eventInfo || {},
          teams: body.teams || [],
          rubrics: body.rubrics || [],
          judges: body.judges || [],
          scores: body.scores || [],
          createdAt: now,
          updatedAt: now,
        };
        
        await dynamodb.put({
          TableName: tableName,
          Item: newEvent,
        }).promise();
        
        return {
          statusCode: 201,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: newEvent,
          }),
        };
        
      case 'update':
      case 'PUT':
        // Update existing event
        if (!body.eventId) {
          throw new Error('eventId is required for update operation');
        }
        
        // Check if event exists
        const existingEvent = await dynamodb.get({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }).promise();
        
        if (!existingEvent.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        // Build update expression
        const updateExpressions = [];
        const expressionAttributeNames = {};
        const expressionAttributeValues = {};
        
        const updateFields = ['title', 'description', 'photos', 'rubric', 'slots', 'teams'];
        updateFields.forEach((field, index) => {
          if (body[field] !== undefined) {
            const nameKey = `#attr${index}`;
            const valueKey = `:val${index}`;
            updateExpressions.push(`${nameKey} = ${valueKey}`);
            expressionAttributeNames[nameKey] = field;
            expressionAttributeValues[valueKey] = body[field];
          }
        });
        
        // Always update updatedAt
        const updatedAtKey = `#attr${updateExpressions.length}`;
        const updatedAtValue = `:val${updateExpressions.length}`;
        updateExpressions.push(`${updatedAtKey} = ${updatedAtValue}`);
        expressionAttributeNames[updatedAtKey] = 'updatedAt';
        expressionAttributeValues[updatedAtValue] = new Date().toISOString();
        
        if (updateExpressions.length === 0) {
          throw new Error('No fields to update');
        }
        
        const updateResult = await dynamodb.update({
          TableName: tableName,
          Key: { eventId: body.eventId },
          UpdateExpression: `SET ${updateExpressions.join(', ')}`,
          ExpressionAttributeNames: expressionAttributeNames,
          ExpressionAttributeValues: expressionAttributeValues,
          ReturnValues: 'ALL_NEW',
        }).promise();
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: updateResult.Attributes,
          }),
        };
        
      case 'updateScores':
        // Atomically append new scores to event.scores array
        if (!body.eventId) {
          throw new Error('eventId is required for updateScores operation');
        }
        
        if (!body.newScores || !Array.isArray(body.newScores) || body.newScores.length === 0) {
          throw new Error('newScores must be a non-empty array');
        }
        
        // Check if event exists
        const eventForScores = await dynamodb.get({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }).promise();
        
        if (!eventForScores.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        // Atomically append new scores to the scores array
        // Using list_append with if_not_exists to handle case where scores array doesn't exist
        const updateScoresResult = await dynamodb.update({
          TableName: tableName,
          Key: { eventId: body.eventId },
          UpdateExpression: 'SET #scores = list_append(if_not_exists(#scores, :empty_list), :new_scores), #updatedAt = :updatedAt',
          ExpressionAttributeNames: {
            '#scores': 'scores',
            '#updatedAt': 'updatedAt',
          },
          ExpressionAttributeValues: {
            ':new_scores': body.newScores,
            ':empty_list': [],
            ':updatedAt': new Date().toISOString(),
          },
          ReturnValues: 'ALL_NEW',
        }).promise();
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: updateScoresResult.Attributes,
          }),
        };
        
      case 'delete':
      case 'DELETE':
        // Delete event
        if (!body.eventId) {
          throw new Error('eventId is required for delete operation');
        }
        
        // Check if event exists
        const eventToDelete = await dynamodb.get({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }).promise();
        
        if (!eventToDelete.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        await dynamodb.delete({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }).promise();
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            message: 'Event deleted successfully',
          }),
        };
        
      default:
        throw new Error(`Unsupported operation: ${operation}`);
    }
    
    // Fallback for unsupported operations
    throw new Error(`Unsupported operation: ${operation}`);
    
  } catch (error) {
    console.error('DynamoDB operation error:', error);
    
    return {
      statusCode: error.statusCode || 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        success: false,
        error: error.message || 'Failed to process DynamoDB operation',
      }),
    };
  }
};

