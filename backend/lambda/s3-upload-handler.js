/**
 * AWS Lambda Function: S3 Resume Upload Handler
 * 
 * This Lambda function receives file uploads from API Gateway and uploads them to S3.
 * It uses the Lambda execution role (auto-generated by AWS Academy) to access S3.
 * 
 * Deployment:
 * 1. Copy this file to Lambda console as index.js (or update handler name)
 * 2. Set handler to: index.handler
 * 3. Set runtime to: Node.js 18.x or later
 * 4. Configure environment variable: S3_BUCKET_NAME
 * 5. Attach IAM policy to execution role: s3:PutObject, s3:PutObjectAcl
 * 6. Set timeout to 30 seconds
 * 7. Set memory to 512 MB (or more for large files)
 * 
 * Note: AWS SDK v2 is built into Lambda runtime, no need to install
 */

const AWS = require('aws-sdk');
const s3 = new AWS.S3();

/**
 * Detect file type from file buffer using magic bytes (file signatures)
 * @param {Buffer} buffer - File buffer
 * @returns {Object} { mimeType: string, extension: string } or null if unknown
 */
const detectFileType = (buffer) => {
  if (!buffer || buffer.length < 4) {
    return null;
  }

  // Get first few bytes
  const header = buffer.slice(0, 8);
  const headerHex = header.toString('hex').toUpperCase();
  const headerStr = buffer.slice(0, 4).toString('utf8');

  // PDF: starts with %PDF
  if (headerStr.startsWith('%PDF')) {
    return { mimeType: 'application/pdf', extension: '.pdf' };
  }

  // DOCX: ZIP file format (starts with PK)
  if (headerStr.startsWith('PK')) {
    // Check if it's actually a DOCX (ZIP with specific structure)
    // DOCX files have [Content_Types].xml in the ZIP
    const zipHeader = buffer.slice(0, 30).toString('utf8');
    if (zipHeader.includes('[Content_Types].xml') || zipHeader.includes('word/')) {
      return { mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', extension: '.docx' };
    }
  }

  // DOC: OLE2 format (starts with D0 CF 11 E0 A1 B1 1A E1)
  if (headerHex.startsWith('D0CF11E0A1B11AE1')) {
    return { mimeType: 'application/msword', extension: '.doc' };
  }

  // Alternative DOC detection: check for OLE2 signature at offset 0
  if (header[0] === 0xD0 && header[1] === 0xCF && header[2] === 0x11 && header[3] === 0xE0) {
    return { mimeType: 'application/msword', extension: '.doc' };
  }

  return null;
};

/**
 * Lambda handler function
 * @param {Object} event - API Gateway event (contains file data)
 * @param {Object} context - Lambda context
 * @returns {Object} API Gateway response
 */
exports.handler = async (event) => {
  console.log('Received upload request');
  console.log('Is base64 encoded:', event.isBase64Encoded);
  console.log('Headers:', JSON.stringify(event.headers, null, 2));
  
  try {
    // Get S3 bucket name from environment variable
    const bucketName = process.env.S3_BUCKET_NAME;
    if (!bucketName) {
      throw new Error('S3_BUCKET_NAME environment variable is not set');
    }

    // Parse the file from the event
    // API Gateway passes binary data as base64-encoded string when binary media types are configured
    let fileBuffer;
    let fileName;
    let contentType;

    // Handle different event formats
    if (event.isBase64Encoded && event.body) {
      // Binary data from API Gateway (base64 encoded) - most common case
      fileBuffer = Buffer.from(event.body, 'base64');
      
      // Extract metadata from headers
      const contentTypeHeader = event.headers['content-type'] || event.headers['Content-Type'] || '';
      const isMultipart = contentTypeHeader.includes('multipart/form-data');
      contentType = contentTypeHeader.split(';')[0].trim();
      
      // Try to extract filename from Content-Disposition header
      const contentDisposition = event.headers['content-disposition'] || event.headers['Content-Disposition'] || '';
      console.log('Content-Disposition:', contentDisposition);
      
      // Try multiple patterns to extract filename
      let filenameMatch = null;
      
      // Pattern 1: filename="file.pdf" or filename='file.pdf'
      filenameMatch = contentDisposition.match(/filename\*?=['"]([^'"]+)['"]/i);
      
      // Pattern 2: filename=file.pdf (unquoted)
      if (!filenameMatch) {
        filenameMatch = contentDisposition.match(/filename\*?=([^;\s]+)/i);
      }
      
      // Pattern 3: filename*=UTF-8''file.pdf (RFC 5987)
      if (!filenameMatch) {
        filenameMatch = contentDisposition.match(/filename\*=UTF-8''([^;\s]+)/i);
        if (filenameMatch) {
          try {
            filenameMatch[1] = decodeURIComponent(filenameMatch[1]);
          } catch (e) {
            // If decoding fails, use as-is
          }
        }
      }
      
      if (filenameMatch && filenameMatch[1]) {
        fileName = filenameMatch[1].trim();
        // Remove quotes if still present
        fileName = fileName.replace(/^["']|["']$/g, '');
        // Extract just the filename if it contains a path
        if (fileName.includes('/') || fileName.includes('\\')) {
          fileName = fileName.split(/[/\\]/).pop();
        }
      } else {
        // Fallback: try to parse from multipart body or use default
        fileName = `resume_${Date.now()}`;
      }
      
      console.log('Extracted filename from headers:', fileName);
      
      // For multipart/form-data, try to extract filename from the body if not in headers
      if (isMultipart && (!fileName || fileName.startsWith('resume_'))) {
        try {
          const bodyStr = fileBuffer.toString('binary');
          
          // Look for filename in the multipart body
          const filenamePatterns = [
            /filename\*?=['"]([^'"]+)['"]/i,
            /filename\*?=([^;\r\n]+)/i,
            /filename\*=UTF-8''([^;\r\n]+)/i
          ];
          
          for (const pattern of filenamePatterns) {
            const match = bodyStr.match(pattern);
            if (match && match[1]) {
              let extractedName = match[1].trim().replace(/^["']|["']$/g, '');
              // Handle URL encoding for RFC 5987 format
              if (extractedName.includes('%')) {
                try {
                  extractedName = decodeURIComponent(extractedName);
                } catch (e) {
                  // If decoding fails, use as-is
                }
              }
              if (extractedName) {
                // Extract just the filename if it contains a path
                if (extractedName.includes('/') || extractedName.includes('\\')) {
                  extractedName = extractedName.split(/[/\\]/).pop();
                }
                if (extractedName && extractedName.includes('.')) {
                  fileName = extractedName;
                  console.log('Extracted filename from multipart body:', fileName);
                  break;
                }
              }
            }
          }
        } catch (parseError) {
          console.warn('Error parsing multipart body for filename:', parseError.message);
        }
      }
      
      // If filename doesn't have extension, try to infer from content-type
      if (!fileName.includes('.')) {
        const extMap = {
          'application/pdf': '.pdf',
          'application/msword': '.doc',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx'
        };
        const ext = extMap[contentType] || '';
        if (ext) {
          fileName = fileName + ext;
        }
      }
    } else if (event.body) {
      // Try to parse as JSON (if API Gateway transforms it)
      try {
        const body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
        
        if (body.file) {
          // File is base64 encoded in JSON
          fileBuffer = Buffer.from(body.file, 'base64');
          fileName = body.fileName || body.filename || `resume_${Date.now()}`;
          contentType = body.contentType || body.content_type || 'application/octet-stream';
        } else {
          throw new Error('File data not found in request body');
        }
      } catch (parseError) {
        // If not JSON, treat as raw binary (fallback)
        fileBuffer = Buffer.from(event.body, 'utf8');
        fileName = event.headers['x-filename'] || `resume_${Date.now()}`;
        contentType = event.headers['content-type'] || 'application/octet-stream';
      }
    } else {
      throw new Error('No file data received');
    }

    // Validate file buffer
    if (!fileBuffer || fileBuffer.length === 0) {
      throw new Error('File buffer is empty');
    }

    // Validate file size (5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB
    if (fileBuffer.length > maxSize) {
      throw new Error('File size exceeds 5MB limit');
    }

    // Detect file type from content (magic bytes) as fallback
    const detectedType = detectFileType(fileBuffer);
    
    // Validate file type (PDF, DOC, DOCX)
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    const allowedExtensions = ['.pdf', '.doc', '.docx'];
    
    // Extract file extension safely
    const lastDotIndex = fileName.toLowerCase().lastIndexOf('.');
    let fileExtension = lastDotIndex > 0 ? fileName.toLowerCase().substring(lastDotIndex) : '';
    
    // If no extension found and we detected a type, add the extension
    if (!fileExtension && detectedType) {
      fileExtension = detectedType.extension;
      fileName = fileName + fileExtension;
      console.log('Added extension based on file content detection:', fileExtension);
    }
    
    // If content-type is generic or missing, use detected type
    if ((!contentType || contentType === 'application/octet-stream' || contentType.includes('multipart/form-data')) && detectedType) {
      contentType = detectedType.mimeType;
      console.log('Updated content-type based on file content detection:', contentType);
    }
    
    console.log('File extension:', fileExtension);
    console.log('Content-Type:', contentType);
    console.log('Detected file type:', detectedType);
    
    // Validate file type - check extension, content-type, or detected type
    const isMultipart = (event.headers['content-type'] || event.headers['Content-Type'] || '').includes('multipart/form-data');
    
    // For multipart/form-data, we need to validate by extension or detected type
    // For other content types, check content-type, extension, or detected type
    const isValidType = isMultipart 
      ? (allowedExtensions.includes(fileExtension) || (detectedType && allowedTypes.includes(detectedType.mimeType)))
      : (allowedTypes.includes(contentType) || allowedExtensions.includes(fileExtension) || (detectedType && allowedTypes.includes(detectedType.mimeType)));
    
    if (!isValidType) {
      throw new Error(`Invalid file type. Only PDF, DOC, and DOCX files are allowed. Received: Content-Type=${contentType}, Extension=${fileExtension}, FileName=${fileName}, DetectedType=${detectedType ? detectedType.mimeType : 'none'}`);
    }

    // Generate unique S3 key
    const timestamp = Date.now();
    const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_');
    const key = `resumes/${timestamp}_${sanitizedFileName}`;

    // Use detected content-type if available, otherwise use provided or default
    const finalContentType = (detectedType && detectedType.mimeType) || contentType || 'application/octet-stream';
    
    // Upload to S3
    const uploadParams = {
      Bucket: bucketName,
      Key: key,
      Body: fileBuffer,
      ContentType: finalContentType,
      ACL: 'private', // Make files private by default
    };

    console.log(`Uploading to S3: ${bucketName}/${key} (${fileBuffer.length} bytes)`);
    const uploadResult = await s3.upload(uploadParams).promise();

    // Return S3 URL
    const s3Url = uploadResult.Location;

    console.log(`Upload successful: ${s3Url}`);

    // Return success response
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*', // Adjust CORS as needed
      },
      body: JSON.stringify({
        success: true,
        url: s3Url,
        key: key,
      }),
    };
  } catch (error) {
    console.error('Upload error:', error);

    // Return error response
    return {
      statusCode: error.statusCode || 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        success: false,
        error: error.message || 'Failed to upload file',
      }),
    };
  }
};
